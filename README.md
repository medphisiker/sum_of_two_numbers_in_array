# 167. Two Sum II - Входной массив отсортирован

Это задача с LeetCode ([ссылка](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/?envType=study-plan-v2&envId=top-interview-150)).

## Описание

* Дан 1-индексированный массив целых чисел `numbers`, который уже отсортирован в неубывающем порядке.

* Найдите два числа такие, что они в сумме дают определенное целевое число. Пусть эти два числа будут `numbers[index1]` и `numbers[index2]`, где `1 <= index1 < index2 <= numbers.length`.

Верните индексы двух чисел, `index1` и `index2`, увеличенные на единицу, в виде целочисленного массива длины 2 `[index1, index2]`.

Тесты сгенерированы таким образом, что существует ровно одно решение. Вы не можете использовать один и тот же элемент дважды.

Ваше решение должно использовать только постоянное дополнительное пространство.

### Пример 1:

**Входные данные:** `numbers = [2,7,11,15]`, `target = 9`  
**Выходные данные:** `[1,2]`  
**Объяснение:** Сумма чисел 2 и 7 равна 9. Поэтому `index1 = 1`, `index2 = 2`. Возвращаем `[1, 2]`.

### Пример 2:

**Входные данные:** `numbers = [2,3,4]`, `target = 6`  
**Выходные данные:** `[1,3]`  
**Объяснение:** Сумма чисел 2 и 4 равна 6. Поэтому `index1 = 1`, `index2 = 3`. Возвращаем `[1, 3]`.

### Пример 3:

**Входные данные:** `numbers = [-1,0]`, `target = -1`  
**Выходные данные:** `[1,2]`  
**Объяснение:** Сумма чисел -1 и 0 равна -1. Поэтому `index1 = 1`, `index2 = 2`. Возвращаем `[1, 2]`.

## Ограничения

- `2 <= numbers.length <= 3 * 10^4`
- `-1000 <= numbers[i] <= 1000`
- Массив `numbers` отсортирован в неубывающем порядке
- `-1000 <= target <= 1000`
- Тесты сгенерированы таким образом, что существует ровно одно решение

## Решение

### Подход с двумя указателями

Для решения задачи используется алгоритм с двумя указателями, который является оптимальным для отсортированного массива.

**Алгоритм:**
1. Инициализируем два указателя: `left` в начале массива и `right` в конце массива
2. Пока `left < right`:
   - Если сумма `numbers[left] + numbers[right]` равна целевой сумме - возвращаем пару индексов
   - Если сумма меньше целевой - увеличиваем `left` (переходим к большему числу)
   - Если сумма больше целевой - уменьшаем `right` (переходим к меньшему числу)
3. Гарантируется, что существует ровно одно решение, поэтому пара всегда будет найдена

**Сложность:**
- Временная: O(n) - в худшем случае проходим массив один раз
- Пространственная: O(1) - используем только два указателя

**Возвращаемое значение:**
- Возвращает список из двух целых чисел, представляющих 1-индексированные позиции элементов, сумма которых равна целевому значению.

**Преимущества:**
- Оптимальная временная и пространственная сложность
- Использует свойство отсортированности массива
- Простая и понятная логика

**Недостатки:**
- Работает только с отсортированным массивом
- Не находит все возможные пары (возвращает первую найденную)

### Альтернативные подходы

**1. Хеш-таблица:**
- Временная сложность: O(n)
- Пространственная сложность: O(n)
- Подходит для неотсортированных массивов
- Требует дополнительной памяти

**2. Бинарный поиск:**
- Временная сложность: O(n log n)
- Пространственная сложность: O(1)
- Для каждого элемента ищем дополнение с помощью бинарного поиска
- Медленнее, чем подход с двумя указателями